public class avl {

    public avl (){

    }


     private static class Node
    {
        int val;
        int height;
        Node left;
        Node right;
        public Node(int val)
        {
            this.val=val;
        }
    
    public int getval()
    {
        return val;
    }
}
private static Node root;

public int height()
{
    return height(root);
}
public  int height(Node node)
{
    if(node==null)
    {
        return -1;
    }
    return node.height;
}
public boolean isEmpty()
{
    return root==null;
}
public void display()
{
    display(this.root,"Root: ");
}
private void display(Node node, String details)
{
    if(node ==null)
    return;

    System.out.println(details+node.val);

    display(node.left,"left child of"+node.val+":");
    display(node.right,"right child of"+node.val+":");


}
//while inserting in a binary serach tree the total number of comparison per
//level is 1.So there are will be at max logN number of comparison
//as there is height of log(N)
public void populate(int []nums)
{
    for(int i=0;i<nums.length;i++)
    {
        this.insert(nums[i]);
    }
}

public void populatesort(int []nums,int start,int end)
{
    if(start>end)
    {
        
        return;
    }
    
    int mid=(start+end)/2;
    this.insert(nums[mid]);
    
    populatesort(nums,start,mid-1);
    populatesort(nums,mid+1,end);
    
}

public void insert(int value)
{
    root=insert(value,root);
}
private Node insert(int value,Node node)
{
    if(node==null)
    {
        node=new Node(value);
        return node;
    }
    if(value<node.val)
    {
        node.left=insert(value,node.left);
    }

     if(value>node.val)
    {
        node.right=insert(value,node.right);
    }
    node.height=Math.max(height(node.left),height(node.right)+1);
    return rotate(node);
}
public Node rotate(Node node)
{
    if(height(node.left)-height(node.right)>1){
        //left heavy
        if(height(node.left.left)-height(node.left.right)>0)
        {
            //left left case
            return rightRotate(node);
        }

       
        if(height(node.left.left)-height(node.left.right)<0)
        //left right case
        {
            
            node.left=leftRotate(node.left);
            return rightRotate(node);
        }

    }


    if(height(node.left)-height(node.right)<-1){
        //right heavy
        if(height(node.right.right)-height(node.right.left)>0)
        {
            //right right case
            return leftRotate(node);
        }

       
        if(height(node.right.right)-height(node.right.left)<0)
        //right left case
        {
            
            node.right=rightRotate(node.right);
            return leftRotate(node);
        }

    }
    return node;
}
public Node rightRotate(Node p)
{
    Node c=p.left;
    Node t=c.right;

    c.right=p;
    p.left=t;

    p.height=Math.max(height(p.left),height(p.right)+1);
    c.height=Math.max(height(c.left),height(c.right)+1);

    return c;

}

public Node leftRotate(Node p)
{
    Node c=p.right;
    Node t=c.left;

    c.left=p;
    p.right=t;

    p.height=Math.max(height(p.left),height(p.right)+1);
    c.height=Math.max(height(c.left),height(c.right)+1);

    return c;

}

public boolean balanced(){
    return balanced(root);
}
private boolean  balanced(Node node)
{
    if(node==null)
    return true;

    return Math.abs(height(node.left)-height(node.right))<=1 && balanced(node.left)
    && balanced(node.right);
}


    public void preorder()
    {
        preorder(root);
    }
    public void preorder(Node node)
    {
        if(node==null)
        return;
        System.err.println(node.val+" ");
        preorder(node.left);
        preorder(node.right);
    }

    public void inorder()
    {
        inorder(root);
    }
    public void inorder(Node node)
    {
        /* if(node.left==null)
        {System.err.println(node.val+" ");
        return;}
        
        inorder(node.left);
        System.out.println(node.val+" ");
        inorder(node.right); */
     
    if (node == null) return;  // base case

    inorder(node.left);                 // visit left
    System.out.println(node.val + " "); // visit root
    inorder(node.right);                // visit right
}

    

}
